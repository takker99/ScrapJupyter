// deno-fmt-ignore-file
// deno-lint-ignore-file
const Xe=e=>e.toLowerCase().replaceAll(" ","_").replace(/[/?#\{}^|<>]/g,t=>encodeURIComponent(t));function Qe(){return(scrapbox.Page.lines?.flatMap(t=>"codeBlock"in t?[t]:[])??[]).reduce((t,{codeBlock:r,text:s,id:c})=>{const i=t.findIndex(({filename:l})=>l!==void 0&&l===r.filename);return r.start&&i<0?[...t,{filename:r.filename,dir:`https://scrpabox.io/api/code/${scrapbox.Project.name}/${Xe(scrapbox.Page.title??"")}`,lang:r.lang,startIds:[c],lines:[]}]:(r.start?t.at(i)?.startIds?.push?.(c):t.at(i)?.lines?.push?.(s),t)},[])}var Ze=Object.defineProperty,et=Object.defineProperties,tt=Object.getOwnPropertyDescriptors,Re=Object.getOwnPropertySymbols,rt=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable,Ce=(e,t,r)=>t in e?Ze(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,Ae=(e,t)=>{for(var r in t||(t={}))rt.call(t,r)&&Ce(e,r,t[r]);if(Re)for(var r of Re(t))nt.call(t,r)&&Ce(e,r,t[r]);return e},Fe=(e,t)=>et(e,tt(t));function Ue(e){let t=s=>{if(s===null)r.write8(0);else if(typeof s=="boolean")r.write8(1),r.write8(+s);else if(typeof s=="number")r.write8(2),r.write32(s|0);else if(typeof s=="string")r.write8(3),r.write(oe(s));else if(s instanceof Uint8Array)r.write8(4),r.write(s);else if(s instanceof Array){r.write8(5),r.write32(s.length);for(let c of s)t(c)}else{let c=Object.keys(s);r.write8(6),r.write32(c.length);for(let i of c)r.write(oe(i)),t(s[i])}},r=new Le;return r.write32(0),r.write32(e.id<<1|+!e.isRequest),t(e.value),_e(r.buf,r.len-4,0),r.buf.subarray(0,r.len)}function lt(e){let t=()=>{switch(r.read8()){case 0:return null;case 1:return!!r.read8();case 2:return r.read32();case 3:return de(r.read());case 4:return r.read();case 5:{let l=r.read32(),d=[];for(let a=0;a<l;a++)d.push(t());return d}case 6:{let l=r.read32(),d={};for(let a=0;a<l;a++)d[de(r.read())]=t();return d}default:throw new Error("Invalid packet")}},r=new Le(e),s=r.read32(),c=(s&1)==0;s>>>=1;let i=t();if(r.ptr!==e.length)throw new Error("Invalid packet");return{id:s,isRequest:c,value:i}}var Le=class{constructor(e=new Uint8Array(1024)){this.buf=e,this.len=0,this.ptr=0}_write(e){if(this.len+e>this.buf.length){let t=new Uint8Array((this.len+e)*2);t.set(this.buf),this.buf=t}return this.len+=e,this.len-e}write8(e){let t=this._write(1);this.buf[t]=e}write32(e){let t=this._write(4);_e(this.buf,e,t)}write(e){let t=this._write(4+e.length);_e(this.buf,e.length,t),this.buf.set(e,t+4)}_read(e){if(this.ptr+e>this.buf.length)throw new Error("Invalid packet");return this.ptr+=e,this.ptr-e}read8(){return this.buf[this._read(1)]}read32(){return Ne(this.buf,this._read(4))}read(){let e=this.read32(),t=new Uint8Array(e),r=this._read(t.length);return t.set(this.buf.subarray(r,r+e)),t}},oe,de;if(typeof TextEncoder!="undefined"&&typeof TextDecoder!="undefined"){let e=new TextEncoder,t=new TextDecoder;oe=r=>e.encode(r),de=r=>t.decode(r)}else if(typeof Buffer!="undefined")oe=e=>{let t=Buffer.from(e);return t instanceof Uint8Array||(t=new Uint8Array(t)),t},de=e=>{let{buffer:t,byteOffset:r,byteLength:s}=e;return Buffer.from(t,r,s).toString()};else throw new Error("No UTF-8 codec found");function Ne(e,t){return e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24}function _e(e,t,r){e[r++]=t,e[r++]=t>>8,e[r++]=t>>16,e[r++]=t>>24}function Be(e){if(e+="",e.indexOf(",")>=0)throw new Error(`Invalid target: ${e}`);return e}var Oe=()=>null,M=e=>typeof e=="boolean"?null:"a boolean",st=e=>typeof e=="boolean"||typeof e=="object"&&!Array.isArray(e)?null:"a boolean or an object",w=e=>typeof e=="string"?null:"a string",Ve=e=>e instanceof RegExp?null:"a RegExp object",pe=e=>typeof e=="number"&&e===(e|0)?null:"an integer",Pe=e=>typeof e=="function"?null:"a function",W=e=>Array.isArray(e)?null:"an array",he=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)?null:"an object",it=e=>typeof e=="object"&&e!==null?null:"an array or an object",Me=e=>typeof e=="object"&&!Array.isArray(e)?null:"an object or null",Ie=e=>typeof e=="string"||typeof e=="boolean"?null:"a string or a boolean",at=e=>typeof e=="string"||typeof e=="object"&&e!==null&&!Array.isArray(e)?null:"a string or an object",ot=e=>typeof e=="string"||Array.isArray(e)?null:"a string or an array",ct=e=>typeof e=="string"||e instanceof Uint8Array?null:"a string or a Uint8Array";function n(e,t,r,s){let c=e[r];if(t[r+""]=!0,c===void 0)return;let i=s(c);if(i!==null)throw new Error(`"${r}" must be ${i}`);return c}function q(e,t,r){for(let s in e)if(!(s in t))throw new Error(`Invalid option ${r}: "${s}"`)}function ut(e){let t=Object.create(null),r=n(e,t,"wasmURL",w),s=n(e,t,"worker",M);return q(e,t,"in startService() call"),{wasmURL:r,worker:s}}function ke(e,t,r,s,c){let i=n(t,r,"color",M),l=n(t,r,"logLevel",w),d=n(t,r,"logLimit",pe);i!==void 0?e.push(`--color=${i}`):s&&e.push("--color=true"),e.push(`--log-level=${l||c}`),e.push(`--log-limit=${d||0}`)}function We(e,t,r){let s=n(t,r,"legalComments",w),c=n(t,r,"sourceRoot",w),i=n(t,r,"sourcesContent",M),l=n(t,r,"target",ot),d=n(t,r,"format",w),a=n(t,r,"globalName",w),E=n(t,r,"minify",M),$=n(t,r,"minifySyntax",M),A=n(t,r,"minifyWhitespace",M),B=n(t,r,"minifyIdentifiers",M),_=n(t,r,"charset",w),F=n(t,r,"treeShaking",Ie),ee=n(t,r,"jsx",w),X=n(t,r,"jsxFactory",w),ne=n(t,r,"jsxFragment",w),te=n(t,r,"define",he),ie=n(t,r,"pure",W),ae=n(t,r,"keepNames",M);if(s&&e.push(`--legal-comments=${s}`),c!==void 0&&e.push(`--source-root=${c}`),i!==void 0&&e.push(`--sources-content=${i}`),l&&(Array.isArray(l)?e.push(`--target=${Array.from(l).map(Be).join(",")}`):e.push(`--target=${Be(l)}`)),d&&e.push(`--format=${d}`),a&&e.push(`--global-name=${a}`),E&&e.push("--minify"),$&&e.push("--minify-syntax"),A&&e.push("--minify-whitespace"),B&&e.push("--minify-identifiers"),_&&e.push(`--charset=${_}`),F!==void 0&&F!==!0&&e.push(`--tree-shaking=${F}`),ee&&e.push(`--jsx=${ee}`),X&&e.push(`--jsx-factory=${X}`),ne&&e.push(`--jsx-fragment=${ne}`),te)for(let H in te){if(H.indexOf("=")>=0)throw new Error(`Invalid define: ${H}`);e.push(`--define:${H}=${te[H]}`)}if(ie)for(let H of ie)e.push(`--pure:${H}`);ae&&e.push("--keep-names")}function ft(e,t,r,s,c){var i;let l=[],d=[],a=Object.create(null),E=null,$=null,A=null;ke(l,t,a,r,s),We(l,t,a);let B=n(t,a,"sourcemap",Ie),_=n(t,a,"bundle",M),F=n(t,a,"watch",st),ee=n(t,a,"splitting",M),X=n(t,a,"preserveSymlinks",M),ne=n(t,a,"metafile",M),te=n(t,a,"outfile",w),ie=n(t,a,"outdir",w),ae=n(t,a,"outbase",w),H=n(t,a,"platform",w),ve=n(t,a,"tsconfig",w),ye=n(t,a,"resolveExtensions",W),Se=n(t,a,"nodePaths",W),$e=n(t,a,"mainFields",W),h=n(t,a,"conditions",W),f=n(t,a,"external",W),u=n(t,a,"loader",he),m=n(t,a,"outExtension",he),N=n(t,a,"publicPath",w),R=n(t,a,"entryNames",w),P=n(t,a,"chunkNames",w),U=n(t,a,"assetNames",w),I=n(t,a,"inject",W),j=n(t,a,"banner",he),x=n(t,a,"footer",he),D=n(t,a,"entryPoints",it),O=n(t,a,"absWorkingDir",w),v=n(t,a,"stdin",he),S=(i=n(t,a,"write",M))!=null?i:c,g=n(t,a,"allowOverwrite",M),y=n(t,a,"incremental",M)===!0;if(a.plugins=!0,q(t,a,`in ${e}() call`),B&&l.push(`--sourcemap${B===!0?"":`=${B}`}`),_&&l.push("--bundle"),g&&l.push("--allow-overwrite"),F)if(l.push("--watch"),typeof F=="boolean")A={};else{let o=Object.create(null),b=n(F,o,"onRebuild",Pe);q(F,o,`on "watch" in ${e}() call`),A={onRebuild:b}}if(ee&&l.push("--splitting"),X&&l.push("--preserve-symlinks"),ne&&l.push("--metafile"),te&&l.push(`--outfile=${te}`),ie&&l.push(`--outdir=${ie}`),ae&&l.push(`--outbase=${ae}`),H&&l.push(`--platform=${H}`),ve&&l.push(`--tsconfig=${ve}`),ye){let o=[];for(let b of ye){if(b+="",b.indexOf(",")>=0)throw new Error(`Invalid resolve extension: ${b}`);o.push(b)}l.push(`--resolve-extensions=${o.join(",")}`)}if(N&&l.push(`--public-path=${N}`),R&&l.push(`--entry-names=${R}`),P&&l.push(`--chunk-names=${P}`),U&&l.push(`--asset-names=${U}`),$e){let o=[];for(let b of $e){if(b+="",b.indexOf(",")>=0)throw new Error(`Invalid main field: ${b}`);o.push(b)}l.push(`--main-fields=${o.join(",")}`)}if(h){let o=[];for(let b of h){if(b+="",b.indexOf(",")>=0)throw new Error(`Invalid condition: ${b}`);o.push(b)}l.push(`--conditions=${o.join(",")}`)}if(f)for(let o of f)l.push(`--external:${o}`);if(j)for(let o in j){if(o.indexOf("=")>=0)throw new Error(`Invalid banner file type: ${o}`);l.push(`--banner:${o}=${j[o]}`)}if(x)for(let o in x){if(o.indexOf("=")>=0)throw new Error(`Invalid footer file type: ${o}`);l.push(`--footer:${o}=${x[o]}`)}if(I)for(let o of I)l.push(`--inject:${o}`);if(u)for(let o in u){if(o.indexOf("=")>=0)throw new Error(`Invalid loader extension: ${o}`);l.push(`--loader:${o}=${u[o]}`)}if(m)for(let o in m){if(o.indexOf("=")>=0)throw new Error(`Invalid out extension: ${o}`);l.push(`--out-extension:${o}=${m[o]}`)}if(D)if(Array.isArray(D))for(let o of D)d.push(["",o+""]);else for(let[o,b]of Object.entries(D))d.push([o+"",b+""]);if(v){let o=Object.create(null),b=n(v,o,"contents",w),p=n(v,o,"resolveDir",w),k=n(v,o,"sourcefile",w),L=n(v,o,"loader",w);q(v,o,'in "stdin" object'),k&&l.push(`--sourcefile=${k}`),L&&l.push(`--loader=${L}`),p&&($=p+""),E=b?b+"":""}let C=[];if(Se)for(let o of Se)o+="",C.push(o);return{entries:d,flags:l,write:S,stdinContents:E,stdinResolveDir:$,absWorkingDir:O,incremental:y,nodePaths:C,watch:A}}function dt(e,t,r,s){let c=[],i=Object.create(null);ke(c,t,i,r,s),We(c,t,i);let l=n(t,i,"sourcemap",Ie),d=n(t,i,"tsconfigRaw",at),a=n(t,i,"sourcefile",w),E=n(t,i,"loader",w),$=n(t,i,"banner",w),A=n(t,i,"footer",w);return q(t,i,`in ${e}() call`),l&&c.push(`--sourcemap=${l===!0?"external":l}`),d&&c.push(`--tsconfig-raw=${typeof d=="string"?d:JSON.stringify(d)}`),a&&c.push(`--sourcefile=${a}`),E&&c.push(`--loader=${E}`),$&&c.push(`--banner=${$}`),A&&c.push(`--footer=${A}`),c}function pt(e){let t=new Map,r=new Map,s=new Map,c=new Map,i=0,l=!1,d=0,a=0,E=new Uint8Array(16*1024),$=0,A=h=>{let f=$+h.length;if(f>E.length){let m=new Uint8Array(f*2);m.set(E),E=m}E.set(h,$),$+=h.length;let u=0;for(;u+4<=$;){let m=Ne(E,u);if(u+4+m>$)break;u+=4,ne(E.subarray(u,u+m)),u+=m}u>0&&(E.copyWithin(0,u,$),$-=u)},B=()=>{l=!0;for(let h of t.values())h("The service was stopped",null);t.clear();for(let h of c.values())h.onWait("The service was stopped");c.clear();for(let h of s.values())try{h(new Error("The service was stopped"),null)}catch(f){console.error(f)}s.clear()},_=(h,f,u)=>{if(l)return u("The service is no longer running",null);let m=d++;t.set(m,(N,R)=>{try{u(N,R)}finally{h&&h.unref()}}),h&&h.ref(),e.writeToStdin(Ue({id:m,isRequest:!0,value:f}))},F=(h,f)=>{if(l)throw new Error("The service is no longer running");e.writeToStdin(Ue({id:h,isRequest:!1,value:f}))},ee=async(h,f)=>{try{switch(f.command){case"ping":{F(h,{});break}case"start":{let u=r.get(f.key);u?F(h,await u(f)):F(h,{});break}case"resolve":{let u=r.get(f.key);u?F(h,await u(f)):F(h,{});break}case"load":{let u=r.get(f.key);u?F(h,await u(f)):F(h,{});break}case"serve-request":{let u=c.get(f.serveID);u&&u.onRequest&&u.onRequest(f.args),F(h,{});break}case"serve-wait":{let u=c.get(f.serveID);u&&u.onWait(f.error),F(h,{});break}case"watch-rebuild":{let u=s.get(f.watchID);try{u&&u(null,f.args)}catch(m){console.error(m)}F(h,{});break}default:throw new Error("Invalid command: "+f.command)}}catch(u){F(h,{errors:[me(u,e,null,void 0,"")]})}},X=!0,ne=h=>{if(X){X=!1;let u=String.fromCharCode(...h);if(u!=="0.12.22")throw new Error(`Cannot start service: Host version "0.12.22" does not match binary version ${JSON.stringify(u)}`);return}let f=lt(h);if(f.isRequest)ee(f.id,f.value);else{let u=t.get(f.id);t.delete(f.id),f.value.error?u(f.value.error,{}):u(null,f.value)}},te=async(h,f,u,m)=>{let N=[],R=[],P={},U={},I=0,j=0,x=[];f=[...f];for(let S of f){let g={};if(typeof S!="object")throw new Error(`Plugin at index ${j} must be an object`);let y=n(S,g,"name",w);if(typeof y!="string"||y==="")throw new Error(`Plugin at index ${j} is missing a name`);try{let C=n(S,g,"setup",Pe);if(typeof C!="function")throw new Error("Plugin is missing a setup function");q(S,g,`on plugin ${JSON.stringify(y)}`);let o={name:y,onResolve:[],onLoad:[]};j++;let b=C({initialOptions:h,onStart(p){let k='This error came from the "onStart" callback registered here',L=xe(new Error(k),e,"onStart");N.push({name:y,callback:p,note:L})},onEnd(p){let k='This error came from the "onEnd" callback registered here',L=xe(new Error(k),e,"onEnd");R.push({name:y,callback:p,note:L})},onResolve(p,k){let L='This error came from the "onResolve" callback registered here',V=xe(new Error(L),e,"onResolve"),G={},J=n(p,G,"filter",Ve),Y=n(p,G,"namespace",w);if(q(p,G,`in onResolve() call for plugin ${JSON.stringify(y)}`),J==null)throw new Error("onResolve() call is missing a filter");let z=I++;P[z]={name:y,callback:k,note:V},o.onResolve.push({id:z,filter:J.source,namespace:Y||""})},onLoad(p,k){let L='This error came from the "onLoad" callback registered here',V=xe(new Error(L),e,"onLoad"),G={},J=n(p,G,"filter",Ve),Y=n(p,G,"namespace",w);if(q(p,G,`in onLoad() call for plugin ${JSON.stringify(y)}`),J==null)throw new Error("onLoad() call is missing a filter");let z=I++;U[z]={name:y,callback:k,note:V},o.onLoad.push({id:z,filter:J.source,namespace:Y||""})}});b&&await b,x.push(o)}catch(C){return{ok:!1,error:C,pluginName:y}}}const D=async S=>{switch(S.command){case"start":{let g={errors:[],warnings:[]};return await Promise.all(N.map(async({name:y,callback:C,note:o})=>{try{let b=await C();if(b!=null){if(typeof b!="object")throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(y)} to return an object`);let p={},k=n(b,p,"errors",W),L=n(b,p,"warnings",W);q(b,p,`from onStart() callback in plugin ${JSON.stringify(y)}`),k!=null&&g.errors.push(...ce(k,"errors",m,y)),L!=null&&g.warnings.push(...ce(L,"warnings",m,y))}}catch(b){g.errors.push(me(b,e,m,o&&o(),y))}})),g}case"resolve":{let g={},y="",C,o;for(let b of S.ids)try{({name:y,callback:C,note:o}=P[b]);let p=await C({path:S.path,importer:S.importer,namespace:S.namespace,resolveDir:S.resolveDir,kind:S.kind,pluginData:m.load(S.pluginData)});if(p!=null){if(typeof p!="object")throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(y)} to return an object`);let k={},L=n(p,k,"pluginName",w),V=n(p,k,"path",w),G=n(p,k,"namespace",w),J=n(p,k,"external",M),Y=n(p,k,"sideEffects",M),z=n(p,k,"pluginData",Oe),le=n(p,k,"errors",W),se=n(p,k,"warnings",W),T=n(p,k,"watchFiles",W),K=n(p,k,"watchDirs",W);q(p,k,`from onResolve() callback in plugin ${JSON.stringify(y)}`),g.id=b,L!=null&&(g.pluginName=L),V!=null&&(g.path=V),G!=null&&(g.namespace=G),J!=null&&(g.external=J),Y!=null&&(g.sideEffects=Y),z!=null&&(g.pluginData=m.store(z)),le!=null&&(g.errors=ce(le,"errors",m,y)),se!=null&&(g.warnings=ce(se,"warnings",m,y)),T!=null&&(g.watchFiles=Ee(T,"watchFiles")),K!=null&&(g.watchDirs=Ee(K,"watchDirs"));break}}catch(p){return{id:b,errors:[me(p,e,m,o&&o(),y)]}}return g}case"load":{let g={},y="",C,o;for(let b of S.ids)try{({name:y,callback:C,note:o}=U[b]);let p=await C({path:S.path,namespace:S.namespace,pluginData:m.load(S.pluginData)});if(p!=null){if(typeof p!="object")throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(y)} to return an object`);let k={},L=n(p,k,"pluginName",w),V=n(p,k,"contents",ct),G=n(p,k,"resolveDir",w),J=n(p,k,"pluginData",Oe),Y=n(p,k,"loader",w),z=n(p,k,"errors",W),le=n(p,k,"warnings",W),se=n(p,k,"watchFiles",W),T=n(p,k,"watchDirs",W);q(p,k,`from onLoad() callback in plugin ${JSON.stringify(y)}`),g.id=b,L!=null&&(g.pluginName=L),V instanceof Uint8Array?g.contents=V:V!=null&&(g.contents=oe(V)),G!=null&&(g.resolveDir=G),J!=null&&(g.pluginData=m.store(J)),Y!=null&&(g.loader=Y),z!=null&&(g.errors=ce(z,"errors",m,y)),le!=null&&(g.warnings=ce(le,"warnings",m,y)),se!=null&&(g.watchFiles=Ee(se,"watchFiles")),T!=null&&(g.watchDirs=Ee(T,"watchDirs"));break}}catch(p){return{id:b,errors:[me(p,e,m,o&&o(),y)]}}return g}default:throw new Error("Invalid command: "+S.command)}};let O=(S,g,y)=>y();R.length>0&&(O=(S,g,y)=>{(async()=>{for(const{name:C,callback:o,note:b}of R)try{await o(S)}catch(p){S.errors.push(await new Promise(k=>g(p,C,b&&b(),k)))}})().then(y)});let v=0;return{ok:!0,requestPlugins:x,runOnEndCallbacks:O,pluginRefs:{ref(){++v==1&&r.set(u,D)},unref(){--v==0&&r.delete(u)}}}},ie=(h,f,u)=>{let m={},N=n(f,m,"port",pe),R=n(f,m,"host",w),P=n(f,m,"servedir",w),U=n(f,m,"onRequest",Pe),I=i++,j,x=new Promise((D,O)=>{j=v=>{c.delete(I),v!==null?O(new Error(v)):D()}});return u.serve={serveID:I},q(f,m,"in serve() call"),N!==void 0&&(u.serve.port=N),R!==void 0&&(u.serve.host=R),P!==void 0&&(u.serve.servedir=P),c.set(I,{onRequest:U,onWait:j}),{wait:x,stop(){_(h,{command:"serve-stop",serveID:I},()=>{})}}};const ae="warning",H="silent";let ve=h=>{let f=a++;const u=Ge();let m,{refs:N,options:R,isTTY:P,callback:U}=h;if(typeof R=="object"){let x=R.plugins;if(x!==void 0){if(!Array.isArray(x))throw new Error('"plugins" must be an array');m=x}}let I=(x,D,O,v)=>{let S=[];try{ke(S,R,{},P,ae)}catch(y){}const g=me(x,e,u,O,D);_(N,{command:"error",flags:S,error:g},()=>{g.detail=u.load(g.detail),v(g)})},j=(x,D)=>{I(x,D,void 0,O=>{U(ge("Build failed",[O],[]),null)})};if(m&&m.length>0){if(e.isSync)return j(new Error("Cannot use plugins in synchronous API calls"),"");te(R,m,f,u).then(x=>{if(!x.ok)j(x.error,x.pluginName);else try{ye(Fe(Ae({},h),{key:f,details:u,logPluginError:I,requestPlugins:x.requestPlugins,runOnEndCallbacks:x.runOnEndCallbacks,pluginRefs:x.pluginRefs}))}catch(D){j(D,"")}},x=>j(x,""))}else try{ye(Fe(Ae({},h),{key:f,details:u,logPluginError:I,requestPlugins:null,runOnEndCallbacks:(x,D,O)=>O(),pluginRefs:null}))}catch(x){j(x,"")}},ye=({callName:h,refs:f,serveOptions:u,options:m,isTTY:N,defaultWD:R,callback:P,key:U,details:I,logPluginError:j,requestPlugins:x,runOnEndCallbacks:D,pluginRefs:O})=>{const v={ref(){O&&O.ref(),f&&f.ref()},unref(){O&&O.unref(),f&&f.unref()}};let S=!e.isBrowser,{entries:g,flags:y,write:C,stdinContents:o,stdinResolveDir:b,absWorkingDir:p,incremental:k,nodePaths:L,watch:V}=ft(h,m,N,ae,S),G={command:"build",key:U,entries:g,flags:y,write:C,stdinContents:o,stdinResolveDir:b,absWorkingDir:p||R,incremental:k,nodePaths:L};x&&(G.plugins=x);let J=u&&ie(v,u,G),Y,z,le=(T,K)=>{T.outputFiles&&(K.outputFiles=T.outputFiles.map(ht)),T.metafile&&(K.metafile=JSON.parse(T.metafile)),T.writeToStdout!==void 0&&console.log(de(T.writeToStdout).replace(/\n$/,""))},se=(T,K)=>{let Q={errors:be(T.errors,I),warnings:be(T.warnings,I)};le(T,Q),D(Q,j,()=>{if(Q.errors.length>0)return K(ge("Build failed",Q.errors,Q.warnings),null);if(T.rebuildID!==void 0){if(!Y){let re=!1;Y=()=>new Promise((ue,fe)=>{if(re||l)throw new Error("Cannot rebuild");_(v,{command:"rebuild",rebuildID:T.rebuildID},(Z,He)=>{if(Z)return K(ge("Build failed",[{pluginName:"",text:Z,location:null,notes:[],detail:void 0}],[]),null);se(He,(je,Ke)=>{je?fe(je):ue(Ke)})})}),v.ref(),Y.dispose=()=>{re||(re=!0,_(v,{command:"rebuild-dispose",rebuildID:T.rebuildID},()=>{}),v.unref())}}Q.rebuild=Y}if(T.watchID!==void 0){if(!z){let re=!1;v.ref(),z=()=>{re||(re=!0,s.delete(T.watchID),_(v,{command:"watch-stop",watchID:T.watchID},()=>{}),v.unref())},V&&s.set(T.watchID,(ue,fe)=>{if(ue){V.onRebuild&&V.onRebuild(ue,null);return}let Z={errors:be(fe.errors,I),warnings:be(fe.warnings,I)};le(fe,Z),D(Z,j,()=>{if(Z.errors.length>0){V.onRebuild&&V.onRebuild(ge("Build failed",Z.errors,Z.warnings),null);return}fe.rebuildID!==void 0&&(Z.rebuild=Y),Z.stop=z,V.onRebuild&&V.onRebuild(null,Z)})})}Q.stop=z}K(null,Q)})};if(C&&e.isBrowser)throw new Error('Cannot enable "write" in the browser');if(k&&e.isSync)throw new Error('Cannot use "incremental" with a synchronous build');_(v,G,(T,K)=>{if(T)return P(new Error(T),null);if(J){let Q=K,re=!1;v.ref();let ue={port:Q.port,host:Q.host,wait:J.wait,stop(){re||(re=!0,J.stop(),v.unref())}};return v.ref(),J.wait.then(v.unref,v.unref),P(null,ue)}return se(K,P)})};return{readFromStdout:A,afterClose:B,service:{buildOrServe:ve,transform:({callName:h,refs:f,input:u,options:m,isTTY:N,fs:R,callback:P})=>{const U=Ge();let I=j=>{try{if(typeof u!="string")throw new Error('The input to "transform" must be a string');let x=dt(h,m,N,H);_(f,{command:"transform",flags:x,inputFS:j!==null,input:j!==null?j:u},(O,v)=>{if(O)return P(new Error(O),null);let S=be(v.errors,U),g=be(v.warnings,U),y=1,C=()=>--y==0&&P(null,{warnings:g,code:v.code,map:v.map});if(S.length>0)return P(ge("Transform failed",S,g),null);v.codeFS&&(y++,R.readFile(v.code,(o,b)=>{o!==null?P(o,null):(v.code=b,C())})),v.mapFS&&(y++,R.readFile(v.map,(o,b)=>{o!==null?P(o,null):(v.map=b,C())})),C()})}catch(x){let D=[];try{ke(D,m,{},N,H)}catch(v){}const O=me(x,e,U,void 0,"");_(f,{command:"error",flags:D,error:O},()=>{O.detail=U.load(O.detail),P(ge("Transform failed",[O],[]),null)})}};if(typeof u=="string"&&u.length>1024*1024){let j=I;I=()=>R.writeFile(u,j)}I(null)},formatMessages:({callName:h,refs:f,messages:u,options:m,callback:N})=>{let R=ce(u,"messages",null,"");if(!m)throw new Error(`Missing second argument in ${h}() call`);let P={},U=n(m,P,"kind",w),I=n(m,P,"color",M),j=n(m,P,"terminalWidth",pe);if(q(m,P,`in ${h}() call`),U===void 0)throw new Error(`Missing "kind" in ${h}() call`);if(U!=="error"&&U!=="warning")throw new Error(`Expected "kind" to be "error" or "warning" in ${h}() call`);let x={command:"format-msgs",messages:R,isWarning:U==="warning"};I!==void 0&&(x.color=I),j!==void 0&&(x.terminalWidth=j),_(f,x,(D,O)=>{if(D)return N(new Error(D),null);N(null,O.messages)})}}}}function Ge(){const e=new Map;let t=0;return{load(r){return e.get(r)},store(r){if(r===void 0)return-1;const s=t++;return e.set(s,r),s}}}function xe(e,t,r){let s,c=!1;return()=>{if(c)return s;c=!0;try{let i=(e.stack+"").split(`
`);i.splice(1,1);let l=Je(t,i,r);if(l)return s={text:e.message,location:l},s}catch(i){}}}function me(e,t,r,s,c){let i="Internal error",l=null;try{i=(e&&e.message||e)+""}catch(d){}try{l=Je(t,(e.stack+"").split(`
`),"")}catch(d){}return{pluginName:c,text:i,location:l,notes:s?[s]:[],detail:r?r.store(e):-1}}function Je(e,t,r){let s="    at ";if(e.readFileSync&&!t[0].startsWith(s)&&t[1].startsWith(s))for(let c=1;c<t.length;c++){let i=t[c];if(!!i.startsWith(s))for(i=i.slice(s.length);;){let l=/^(?:new |async )?\S+ \((.*)\)$/.exec(i);if(l){i=l[1];continue}if(l=/^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(i),l){i=l[1];continue}if(l=/^(\S+):(\d+):(\d+)$/.exec(i),l){let d;try{d=e.readFileSync(l[1],"utf8")}catch(A){break}let a=d.split(/\r\n|\r|\n|\u2028|\u2029/)[+l[2]-1]||"",E=+l[3]-1,$=a.slice(E,E+r.length)===r?r.length:0;return{file:l[1],namespace:"file",line:+l[2],column:oe(a.slice(0,E)).length,length:oe(a.slice(E,E+$)).length,lineText:a+`
`+t.slice(1).join(`
`),suggestion:""}}break}}return null}function ge(e,t,r){let s=5,c=t.length<1?"":` with ${t.length} error${t.length<2?"":"s"}:`+t.slice(0,s+1).map((l,d)=>{if(d===s)return`
...`;if(!l.location)return`
error: ${l.text}`;let{file:a,line:E,column:$}=l.location,A=l.pluginName?`[plugin: ${l.pluginName}] `:"";return`
${a}:${E}:${$}: error: ${A}${l.text}`}).join(""),i=new Error(`${e}${c}`);return i.errors=t,i.warnings=r,i}function be(e,t){for(const r of e)r.detail=t.load(r.detail);return e}function ze(e,t){if(e==null)return null;let r={},s=n(e,r,"file",w),c=n(e,r,"namespace",w),i=n(e,r,"line",pe),l=n(e,r,"column",pe),d=n(e,r,"length",pe),a=n(e,r,"lineText",w),E=n(e,r,"suggestion",w);return q(e,r,t),{file:s||"",namespace:c||"",line:i||0,column:l||0,length:d||0,lineText:a||"",suggestion:E||""}}function ce(e,t,r,s){let c=[],i=0;for(const l of e){let d={},a=n(l,d,"pluginName",w),E=n(l,d,"text",w),$=n(l,d,"location",Me),A=n(l,d,"notes",W),B=n(l,d,"detail",Oe),_=`in element ${i} of "${t}"`;q(l,d,_);let F=[];if(A)for(const ee of A){let X={},ne=n(ee,X,"text",w),te=n(ee,X,"location",Me);q(ee,X,_),F.push({text:ne||"",location:ze(te,_)})}c.push({pluginName:a||s,text:E||"",location:ze($,_),notes:F,detail:r?r.store(B):-1}),i++}return c}function Ee(e,t){const r=[];for(const s of e){if(typeof s!="string")throw new Error(`${JSON.stringify(t)} must be an array of strings`);r.push(s)}return r}function ht({path:e,contents:t}){let r=null;return{path:e,contents:t,get text(){return r===null&&(r=de(t)),r}}}var mt=e=>gt().build(e),Bt=()=>{throw new Error('The "serve" API only works in node')},Vt=()=>{throw new Error('The "buildSync" API only works in node')},Mt=()=>{throw new Error('The "transformSync" API only works in node')},Wt=()=>{throw new Error('The "formatMessagesSync" API only works in node')},we,Te,gt=()=>{if(Te)return Te;throw we?new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this'):new Error('You need to call "initialize" before calling this')},bt=e=>{e=ut(e||{});let t=e.wasmURL,r=e.worker!==!1;if(!t)throw new Error('Must provide the "wasmURL" option');if(t+="",we)throw new Error('Cannot call "initialize" more than once');return we=wt(t,r),we.catch(()=>{we=void 0}),we},wt=async(e,t)=>{let r=await fetch(e);if(!r.ok)throw new Error(`Failed to download ${JSON.stringify(e)}`);let s=await r.arrayBuffer(),c=`{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

(() => {
	// Map multiple JavaScript environments to a single common API,
	// preferring web standards over Node.js API.
	//
	// Environments considered:
	// - Browsers
	// - Node.js
	// - Electron
	// - Parcel
	// - Webpack

	if (typeof global !== "undefined") {
		// global already exists
	} else if (typeof window !== "undefined") {
		window.global = window;
	} else if (typeof self !== "undefined") {
		self.global = self;
	} else {
		throw new Error("cannot export Go (neither global, window nor self is defined)");
	}

	if (!global.require && typeof require !== "undefined") {
		global.require = require;
	}

	if (!global.fs && global.require) {
		const fs = require("fs");
		if (typeof fs === "object" && fs !== null && Object.keys(fs).length !== 0) {
			
    global.fs = Object.assign({}, fs, {
      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550
      write(fd, buf, offset, length, position, callback) {
        if (offset === 0 && length === buf.length && position === null) {
          if (fd === process.stdout.fd) {
            try {
              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));
            } catch (err) {
              callback(err, 0, null);
            }
            return;
          }
          if (fd === process.stderr.fd) {
            try {
              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));
            } catch (err) {
              callback(err, 0, null);
            }
            return;
          }
        }
        fs.write(fd, buf, offset, length, position, callback);
      },
    });
  
		}
	}

	const enosys = () => {
		const err = new Error("not implemented");
		err.code = "ENOSYS";
		return err;
	};

	if (!global.fs) {
		let outputBuf = "";
		global.fs = {
			constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused
			writeSync(fd, buf) {
				outputBuf += decoder.decode(buf);
				const nl = outputBuf.lastIndexOf("\\n");
				if (nl != -1) {
					console.log(outputBuf.substr(0, nl));
					outputBuf = outputBuf.substr(nl + 1);
				}
				return buf.length;
			},
			write(fd, buf, offset, length, position, callback) {
				if (offset !== 0 || length !== buf.length || position !== null) {
					callback(enosys());
					return;
				}
				const n = this.writeSync(fd, buf);
				callback(null, n);
			},
			chmod(path, mode, callback) { callback(enosys()); },
			chown(path, uid, gid, callback) { callback(enosys()); },
			close(fd, callback) { callback(enosys()); },
			fchmod(fd, mode, callback) { callback(enosys()); },
			fchown(fd, uid, gid, callback) { callback(enosys()); },
			fstat(fd, callback) { callback(enosys()); },
			fsync(fd, callback) { callback(null); },
			ftruncate(fd, length, callback) { callback(enosys()); },
			lchown(path, uid, gid, callback) { callback(enosys()); },
			link(path, link, callback) { callback(enosys()); },
			lstat(path, callback) { callback(enosys()); },
			mkdir(path, perm, callback) { callback(enosys()); },
			open(path, flags, mode, callback) { callback(enosys()); },
			read(fd, buffer, offset, length, position, callback) { callback(enosys()); },
			readdir(path, callback) { callback(enosys()); },
			readlink(path, callback) { callback(enosys()); },
			rename(from, to, callback) { callback(enosys()); },
			rmdir(path, callback) { callback(enosys()); },
			stat(path, callback) { callback(enosys()); },
			symlink(path, link, callback) { callback(enosys()); },
			truncate(path, length, callback) { callback(enosys()); },
			unlink(path, callback) { callback(enosys()); },
			utimes(path, atime, mtime, callback) { callback(enosys()); },
		};
	}

	if (!global.process) {
		global.process = {
			getuid() { return -1; },
			getgid() { return -1; },
			geteuid() { return -1; },
			getegid() { return -1; },
			getgroups() { throw enosys(); },
			pid: -1,
			ppid: -1,
			umask() { throw enosys(); },
			cwd() { throw enosys(); },
			chdir() { throw enosys(); },
		}
	}

	if (!global.crypto && global.require) {
		const nodeCrypto = require("crypto");
		global.crypto = {
			getRandomValues(b) {
				nodeCrypto.randomFillSync(b);
			},
		};
	}
	if (!global.crypto) {
		throw new Error("global.crypto is not available, polyfill required (getRandomValues only)");
	}

	if (!global.performance) {
		global.performance = {
			now() {
				const [sec, nsec] = process.hrtime();
				return sec * 1000 + nsec / 1000000;
			},
		};
	}

	if (!global.TextEncoder && global.require) {
		global.TextEncoder = require("util").TextEncoder;
	}
	if (!global.TextEncoder) {
		throw new Error("global.TextEncoder is not available, polyfill required");
	}

	if (!global.TextDecoder && global.require) {
		global.TextDecoder = require("util").TextDecoder;
	}
	if (!global.TextDecoder) {
		throw new Error("global.TextDecoder is not available, polyfill required");
	}

	// End of polyfills for common API.

	const encoder = new TextEncoder("utf-8");
	const decoder = new TextDecoder("utf-8");

	global.Go = class {
		constructor() {
			this.argv = ["js"];
			this.env = {};
			this.exit = (code) => {
				if (code !== 0) {
					console.warn("exit code:", code);
				}
			};
			this._exitPromise = new Promise((resolve) => {
				this._resolveExitPromise = resolve;
			});
			this._pendingEvent = null;
			this._scheduledTimeouts = new Map();
			this._nextCallbackTimeoutID = 1;

			const setInt64 = (addr, v) => {
				this.mem.setUint32(addr + 0, v, true);
				this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);
			}

			const getInt64 = (addr) => {
				const low = this.mem.getUint32(addr + 0, true);
				const high = this.mem.getInt32(addr + 4, true);
				return low + high * 4294967296;
			}

			const loadValue = (addr) => {
				const f = this.mem.getFloat64(addr, true);
				if (f === 0) {
					return undefined;
				}
				if (!isNaN(f)) {
					return f;
				}

				const id = this.mem.getUint32(addr, true);
				return this._values[id];
			}

			const storeValue = (addr, v) => {
				const nanHead = 0x7FF80000;

				if (typeof v === "number" && v !== 0) {
					if (isNaN(v)) {
						this.mem.setUint32(addr + 4, nanHead, true);
						this.mem.setUint32(addr, 0, true);
						return;
					}
					this.mem.setFloat64(addr, v, true);
					return;
				}

				if (v === undefined) {
					this.mem.setFloat64(addr, 0, true);
					return;
				}

				let id = this._ids.get(v);
				if (id === undefined) {
					id = this._idPool.pop();
					if (id === undefined) {
						id = this._values.length;
					}
					this._values[id] = v;
					this._goRefCounts[id] = 0;
					this._ids.set(v, id);
				}
				this._goRefCounts[id]++;
				let typeFlag = 0;
				switch (typeof v) {
					case "object":
						if (v !== null) {
							typeFlag = 1;
						}
						break;
					case "string":
						typeFlag = 2;
						break;
					case "symbol":
						typeFlag = 3;
						break;
					case "function":
						typeFlag = 4;
						break;
				}
				this.mem.setUint32(addr + 4, nanHead | typeFlag, true);
				this.mem.setUint32(addr, id, true);
			}

			const loadSlice = (addr) => {
				const array = getInt64(addr + 0);
				const len = getInt64(addr + 8);
				return new Uint8Array(this._inst.exports.mem.buffer, array, len);
			}

			const loadSliceOfValues = (addr) => {
				const array = getInt64(addr + 0);
				const len = getInt64(addr + 8);
				const a = new Array(len);
				for (let i = 0; i < len; i++) {
					a[i] = loadValue(array + i * 8);
				}
				return a;
			}

			const loadString = (addr) => {
				const saddr = getInt64(addr + 0);
				const len = getInt64(addr + 8);
				return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));
			}

			const timeOrigin = Date.now() - performance.now();
			this.importObject = {
				go: {
					// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)
					// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported
					// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).
					// This changes the SP, thus we have to update the SP used by the imported function.

					// func wasmExit(code int32)
					"runtime.wasmExit": (sp) => {
						sp >>>= 0;
						const code = this.mem.getInt32(sp + 8, true);
						this.exited = true;
						delete this._inst;
						delete this._values;
						delete this._goRefCounts;
						delete this._ids;
						delete this._idPool;
						this.exit(code);
					},

					// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)
					"runtime.wasmWrite": (sp) => {
						sp >>>= 0;
						const fd = getInt64(sp + 8);
						const p = getInt64(sp + 16);
						const n = this.mem.getInt32(sp + 24, true);
						fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));
					},

					// func resetMemoryDataView()
					"runtime.resetMemoryDataView": (sp) => {
						sp >>>= 0;
						this.mem = new DataView(this._inst.exports.mem.buffer);
					},

					// func nanotime1() int64
					"runtime.nanotime1": (sp) => {
						sp >>>= 0;
						setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);
					},

					// func walltime() (sec int64, nsec int32)
					"runtime.walltime": (sp) => {
						sp >>>= 0;
						const msec = (new Date).getTime();
						setInt64(sp + 8, msec / 1000);
						this.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);
					},

					// func scheduleTimeoutEvent(delay int64) int32
					"runtime.scheduleTimeoutEvent": (sp) => {
						sp >>>= 0;
						const id = this._nextCallbackTimeoutID;
						this._nextCallbackTimeoutID++;
						this._scheduledTimeouts.set(id, setTimeout(
							() => {
								this._resume();
								while (this._scheduledTimeouts.has(id)) {
									// for some reason Go failed to register the timeout event, log and try again
									// (temporary workaround for https://github.com/golang/go/issues/28975)
									console.warn("scheduleTimeoutEvent: missed timeout event");
									this._resume();
								}
							},
							getInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early
						));
						this.mem.setInt32(sp + 16, id, true);
					},

					// func clearTimeoutEvent(id int32)
					"runtime.clearTimeoutEvent": (sp) => {
						sp >>>= 0;
						const id = this.mem.getInt32(sp + 8, true);
						clearTimeout(this._scheduledTimeouts.get(id));
						this._scheduledTimeouts.delete(id);
					},

					// func getRandomData(r []byte)
					"runtime.getRandomData": (sp) => {
						sp >>>= 0;
						crypto.getRandomValues(loadSlice(sp + 8));
					},

					// func finalizeRef(v ref)
					"syscall/js.finalizeRef": (sp) => {
						sp >>>= 0;
						const id = this.mem.getUint32(sp + 8, true);
						this._goRefCounts[id]--;
						if (this._goRefCounts[id] === 0) {
							const v = this._values[id];
							this._values[id] = null;
							this._ids.delete(v);
							this._idPool.push(id);
						}
					},

					// func stringVal(value string) ref
					"syscall/js.stringVal": (sp) => {
						sp >>>= 0;
						storeValue(sp + 24, loadString(sp + 8));
					},

					// func valueGet(v ref, p string) ref
					"syscall/js.valueGet": (sp) => {
						sp >>>= 0;
						const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));
						sp = this._inst.exports.getsp() >>> 0; // see comment above
						storeValue(sp + 32, result);
					},

					// func valueSet(v ref, p string, x ref)
					"syscall/js.valueSet": (sp) => {
						sp >>>= 0;
						Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));
					},

					// func valueDelete(v ref, p string)
					"syscall/js.valueDelete": (sp) => {
						sp >>>= 0;
						Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));
					},

					// func valueIndex(v ref, i int) ref
					"syscall/js.valueIndex": (sp) => {
						sp >>>= 0;
						storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));
					},

					// valueSetIndex(v ref, i int, x ref)
					"syscall/js.valueSetIndex": (sp) => {
						sp >>>= 0;
						Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));
					},

					// func valueCall(v ref, m string, args []ref) (ref, bool)
					"syscall/js.valueCall": (sp) => {
						sp >>>= 0;
						try {
							const v = loadValue(sp + 8);
							const m = Reflect.get(v, loadString(sp + 16));
							const args = loadSliceOfValues(sp + 32);
							const result = Reflect.apply(m, v, args);
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 56, result);
							this.mem.setUint8(sp + 64, 1);
						} catch (err) {
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 56, err);
							this.mem.setUint8(sp + 64, 0);
						}
					},

					// func valueInvoke(v ref, args []ref) (ref, bool)
					"syscall/js.valueInvoke": (sp) => {
						sp >>>= 0;
						try {
							const v = loadValue(sp + 8);
							const args = loadSliceOfValues(sp + 16);
							const result = Reflect.apply(v, undefined, args);
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 40, result);
							this.mem.setUint8(sp + 48, 1);
						} catch (err) {
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 40, err);
							this.mem.setUint8(sp + 48, 0);
						}
					},

					// func valueNew(v ref, args []ref) (ref, bool)
					"syscall/js.valueNew": (sp) => {
						sp >>>= 0;
						try {
							const v = loadValue(sp + 8);
							const args = loadSliceOfValues(sp + 16);
							const result = Reflect.construct(v, args);
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 40, result);
							this.mem.setUint8(sp + 48, 1);
						} catch (err) {
							sp = this._inst.exports.getsp() >>> 0; // see comment above
							storeValue(sp + 40, err);
							this.mem.setUint8(sp + 48, 0);
						}
					},

					// func valueLength(v ref) int
					"syscall/js.valueLength": (sp) => {
						sp >>>= 0;
						setInt64(sp + 16, parseInt(loadValue(sp + 8).length));
					},

					// valuePrepareString(v ref) (ref, int)
					"syscall/js.valuePrepareString": (sp) => {
						sp >>>= 0;
						const str = encoder.encode(String(loadValue(sp + 8)));
						storeValue(sp + 16, str);
						setInt64(sp + 24, str.length);
					},

					// valueLoadString(v ref, b []byte)
					"syscall/js.valueLoadString": (sp) => {
						sp >>>= 0;
						const str = loadValue(sp + 8);
						loadSlice(sp + 16).set(str);
					},

					// func valueInstanceOf(v ref, t ref) bool
					"syscall/js.valueInstanceOf": (sp) => {
						sp >>>= 0;
						this.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);
					},

					// func copyBytesToGo(dst []byte, src ref) (int, bool)
					"syscall/js.copyBytesToGo": (sp) => {
						sp >>>= 0;
						const dst = loadSlice(sp + 8);
						const src = loadValue(sp + 32);
						if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {
							this.mem.setUint8(sp + 48, 0);
							return;
						}
						const toCopy = src.subarray(0, dst.length);
						dst.set(toCopy);
						setInt64(sp + 40, toCopy.length);
						this.mem.setUint8(sp + 48, 1);
					},

					// func copyBytesToJS(dst ref, src []byte) (int, bool)
					"syscall/js.copyBytesToJS": (sp) => {
						sp >>>= 0;
						const dst = loadValue(sp + 8);
						const src = loadSlice(sp + 16);
						if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {
							this.mem.setUint8(sp + 48, 0);
							return;
						}
						const toCopy = src.subarray(0, dst.length);
						dst.set(toCopy);
						setInt64(sp + 40, toCopy.length);
						this.mem.setUint8(sp + 48, 1);
					},

					"debug": (value) => {
						console.log(value);
					},
				}
			};
		}

		async run(instance) {
			if (!(instance instanceof WebAssembly.Instance)) {
				throw new Error("Go.run: WebAssembly.Instance expected");
			}
			this._inst = instance;
			this.mem = new DataView(this._inst.exports.mem.buffer);
			this._values = [ // JS values that Go currently has references to, indexed by reference id
				NaN,
				0,
				null,
				true,
				false,
				global,
				this,
			];
			this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id
			this._ids = new Map([ // mapping from JS values to reference ids
				[0, 1],
				[null, 2],
				[true, 3],
				[false, 4],
				[global, 5],
				[this, 6],
			]);
			this._idPool = [];   // unused ids that have been garbage collected
			this.exited = false; // whether the Go program has exited

			// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.
			let offset = 4096;

			const strPtr = (str) => {
				const ptr = offset;
				const bytes = encoder.encode(str + "\\0");
				new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);
				offset += bytes.length;
				if (offset % 8 !== 0) {
					offset += 8 - (offset % 8);
				}
				return ptr;
			};

			const argc = this.argv.length;

			const argvPtrs = [];
			this.argv.forEach((arg) => {
				argvPtrs.push(strPtr(arg));
			});
			argvPtrs.push(0);

			const keys = Object.keys(this.env).sort();
			keys.forEach((key) => {
				argvPtrs.push(strPtr(\`\${key}=\${this.env[key]}\`));
			});
			argvPtrs.push(0);

			const argv = offset;
			argvPtrs.forEach((ptr) => {
				this.mem.setUint32(offset, ptr, true);
				this.mem.setUint32(offset + 4, 0, true);
				offset += 8;
			});

			this._inst.exports.run(argc, argv);
			if (this.exited) {
				this._resolveExitPromise();
			}
			await this._exitPromise;
		}

		_resume() {
			if (this.exited) {
				throw new Error("Go program has already exited");
			}
			this._inst.exports.resume();
			if (this.exited) {
				this._resolveExitPromise();
			}
		}

		_makeFuncWrapper(id) {
			const go = this;
			return function () {
				const event = { id: id, this: this, args: arguments };
				go._pendingEvent = event;
				go._resume();
				return event.result;
			};
		}
	}

	if (
		typeof module !== "undefined" &&
		global.require &&
		global.require.main === module &&
		global.process &&
		global.process.versions &&
		!global.process.versions.electron
	) {
		if (process.argv.length < 3) {
			console.error("usage: go_js_wasm_exec [wasm binary] [arguments]");
			process.exit(1);
		}

		const go = new Go();
		go.argv = process.argv.slice(2);
		go.env = Object.assign({ TMPDIR: require("os").tmpdir() }, process.env);
		go.exit = process.exit;
		WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {
			process.on("exit", (code) => { // Node.js exits if no event handler is pending
				if (code === 0 && !go.exited) {
					// deadlock, make Go print error and stack traces
					go._pendingEvent = { id: 0 };
					go._resume();
				}
			});
			return go.run(result.instance);
		}).catch((err) => {
			console.error(err);
			process.exit(1);
		});
	}
})();
onmessage = ({ data: wasm }) => {
  let decoder = new TextDecoder();
  let fs = global.fs;
  let stderr = "";
  fs.writeSync = (fd, buffer) => {
    if (fd === 1) {
      postMessage(buffer);
    } else if (fd === 2) {
      stderr += decoder.decode(buffer);
      let parts = stderr.split("\\n");
      if (parts.length > 1)
        console.log(parts.slice(0, -1).join("\\n"));
      stderr = parts[parts.length - 1];
    } else {
      throw new Error("Bad write");
    }
    return buffer.length;
  };
  let stdin = [];
  let resumeStdin;
  let stdinPos = 0;
  onmessage = ({ data }) => {
    if (data.length > 0) {
      stdin.push(data);
      if (resumeStdin)
        resumeStdin();
    }
  };
  fs.read = (fd, buffer, offset, length, position, callback) => {
    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {
      throw new Error("Bad read");
    }
    if (stdin.length === 0) {
      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);
      return;
    }
    let first = stdin[0];
    let count = Math.max(0, Math.min(length, first.length - stdinPos));
    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);
    stdinPos += count;
    if (stdinPos === first.length) {
      stdin.shift();
      stdinPos = 0;
    }
    callback(null, count);
  };
  let go = new global.Go();
  go.argv = ["", \`--service=\${"0.12.22"}\`];
  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));
};}`,i;if(t){let a=new Blob([c],{type:"text/javascript"});i=new Worker(URL.createObjectURL(a))}else{let E=new Function("postMessage",c+"var onmessage; return m => onmessage(m)")($=>i.onmessage({data:$}));i={onmessage:null,postMessage:$=>E({data:$}),terminate(){}}}i.postMessage(s),i.onmessage=({data:a})=>l(a);let{readFromStdout:l,service:d}=pt({writeToStdin(a){i.postMessage(a)},isSync:!1,isBrowser:!0});Te={build:a=>new Promise((E,$)=>d.buildOrServe({callName:"build",refs:null,serveOptions:null,options:a,isTTY:!1,defaultWD:"/",callback:(A,B)=>A?$(A):E(B)})),transform:(a,E)=>new Promise(($,A)=>d.transform({callName:"transform",refs:null,input:a,options:E||{},isTTY:!1,fs:{readFile(B,_){_(new Error("Internal error"),null)},writeFile(B,_){_(null)}},callback:(B,_)=>B?A(B):$(_)})),formatMessages:(a,E)=>new Promise(($,A)=>d.formatMessages({callName:"formatMessages",refs:null,messages:a,options:E,callback:(B,_)=>B?A(B):$(_)}))}};let yt="http-fetch",vt=({onResolve:e,onLoad:t})=>{e({filter:/^https:\/\//},kt),e({filter:/.*/,namespace:"http-fetch"},xt),t({filter:/.*/,namespace:"http-fetch"},Et)},kt=({path:e})=>({path:e,namespace:"http-fetch"}),xt=({path:e,importer:t})=>({path:new URL(e,t).href,namespace:"http-fetch"}),Et=async({path:e})=>{let t=await fetch(e);if(!t.ok){let d=`GET ${e} failed: status ${t.status}`;throw new Error(d)}let r=await t.text(),s=/\/\/# sourceMappingURL=(\S+)/,c=r.match(s);if(c){let d=new URL(c[1],t.url),E=`//# sourceMappingURL=${await St(d)}`;r=r.replace(s,E)}let{pathname:i}=new URL(t.url),l=i.match(/[^.]+$/)[0];return{contents:r,loader:l}},St=async e=>{let t=await fetch(e),r=t.headers.get("content-type").replace(/\s/g,""),s=await t.arrayBuffer(),c=new Blob([s],{type:r}),i=new FileReader;return new Promise(l=>{i.onload=d=>l(d.target.result),i.readAsDataURL(c)})};const $t={name:yt,setup:vt};let De;async function jt(){return De===void 0&&(De=bt({wasmURL:"https://scrapbox.io/files/61231ff40ef655001d6f7109.wasm"})),await De}function _t(e){return["ts","js","tsx","jsx","mjs","javascript","typescript"].includes(e)}async function Ot(e,{extension:t,fileName:r,resolveDir:s}){await jt();const{outputFiles:c}=await mt({stdin:{contents:e,loader:Pt(t),resolveDir:s,sourcefile:r},format:"esm",bundle:!0,minify:!0,charset:"utf8",plugins:[$t],write:!1});return c[0].text}function Pt(e){switch(e){case"javascript":case"js":case"mjs":return"js";case"typescript":case"ts":return"ts";case"jsx":return"jsx";case"tsx":return"tsx"}}function It(){const e=document.createElement("i");return e.classList.add("kamon","kamon-check-circle-fill"),e.style.color="hsl(133, 46.1%, 47.3%)",e}function Tt(){const e=document.createElement("i");return e.classList.add("kamon","kamon-cross-circle"),e.style.color="hsl(1.7, 64.5%, 58%)",e}function Dt(){const e=document.createElement("i");return e.classList.add("i","fa","fa-spinner"),e}function Rt(){const e=document.createElement("i");return e.classList.add("kamon","kamon-play"),e}function Ct(){let e;return{show:(s,{x:c,y:i})=>{e=At(),e.append(Ft(s)),e.style.visibility="hidden",document.body.append(e);const{height:l}=e.getBoundingClientRect();e.style.top=`${i-l}px`,e.style.left=`${c}px`,e.style.removeProperty("visibility")},hide:async()=>{e?.classList?.remove?.("in"),await new Promise(s=>setTimeout(s,150)),e?.remove?.()}}}function At(){const e=document.createElement("div");return e.setAttribute("role","tooltip"),e.classList.add("fade","in","tooltip","top"),e}function Ft(e){const t=document.createElement("pre");return t.classList.add("tooltip-inner"),t.style.textAlign="unset",t.style.maxWidth="70vw",t.style.margin="unset",t.innerText=e,t}function Ut(){const e=document.createElement("a");e.classList.add("tool-btn"),e.type="button",e.setAttribute("aria-haspopup","true");let t=!1;const{show:r,hide:s}=Ct();return{component:e,setStatus:async(i,l)=>{switch(e.textContent="",await s(),i){case"loading":e.append(Dt());break;case"pass":e.append(It());break;case"fail":e.append(Tt());break;case"none":break}l!==void 0&&i!=="none"?(e.style.removeProperty("pointer-events"),e.onclick=async()=>{if(t)await s();else{const{top:d,left:a}=e.getBoundingClientRect();r(l,{y:d+window.scrollY,x:a})}t=!t}):e.style.pointerEvents="none"}}}function Lt(e){const t=document.createElement("a");return t.classList.add("tool-btn"),t.type="button",t.setAttribute("aria-haspopup","true"),t.append(Rt()),t.addEventListener("click",e),t}function Nt(e){const{component:t,setStatus:r}=Ut(),s=document.createElement("div");return s.style.position="absolute",s.style.left="-2em",s.style.zIndex="1",s.style.display="flex",s.style.flexFlow="column",s.append(Lt(e),t),{menu:s,setStatus:r}}const qe=[],Ye=()=>{const e=Qe();qe.forEach(({menu:t,setStatus:r})=>{r("none"),t.remove()}),e.forEach(t=>{const r=t.lang.toLowerCase();!_t(r)||t.startIds.forEach(s=>{const c=document.getElementById(`L${s}`),{menu:i,setStatus:l}=Nt(async()=>{await l("loading");try{const d=await Ot(t.lines.join(`
`),{extension:r,fileName:t.filename,resolveDir:t.dir});console.log("execute:",d),await Function(`return (async()=>{${d}})()`)(),await l("pass")}catch(d){await l("fail",d.toString())}});qe.push({menu:i,setStatus:l}),c?.insertBefore?.(i,c?.firstElementChild)})})};Ye(),scrapbox.addListener("lines:changed",Ye);
